## goit-algo-hw-02

------------


# Домашнє завдання до теми “Основні структури даних”

------------


## Завдання 1: Симуляція роботи сервісного центру

**Мета:** *Розробити програму, яка імітує приймання й обробку заявок за допомогою черги.  Програма повинна автоматично генерувати нові заявки, додавати їх до черги, а потім послідовно видаляти з черги для "обробки". *

**Структура даних:** Черга (***queue.Queue*** з модуля ***queue***).

### Підхід:

1. Створимо чергу для зберігання заявок.

2. Функція ***generate_request()*** буде створювати нову заявку (з унікальним ідентифікатором) та додавати її до черги. 

3. Функція ***process_request()*** буде вилучати заявку з черги для обробки, якщо черга не порожня.  Якщо черга порожня, буде виведено відповідне повідомлення.

4. Основний цикл програми буде імітувати потік створення та обробки заявок, працюючи доки користувач не перерве виконання (наприклад, натисканням ***Ctrl+C*** ).

**Ось код для реалізації:**

````python
import queue
import time
import random
import uuid

# Створити чергу заявок
request_queue = queue.Queue()

def generate_request():
    """
    Генерує нову заявку з унікальним ID та додає її до черги.
    """
    request_id = uuid.uuid4()
    request_data = {"id": request_id, "data": f"Заявка з ID {request_id}"}
    request_queue.put(request_data)
    print(f"Нова заявка створена та додана до черги: ID {request_id}")

def process_request():
    """
    Обробляє заявку з черги.
    Якщо черга порожня, виводить відповідне повідомлення.
    """
    if not request_queue.empty():
        request_to_process = request_queue.get()
        print(f"Обробка заявки: {request_to_process['data']}...")
        # Імітація часу на обробку
        time.sleep(random.uniform(0.5, 1.5))
        print(f"Заявка {request_to_process['id']} оброблена.")
        request_queue.task_done() # Повідомляємо черзі, що завдання виконано (для join())
    else:
        print("Черга пуста, немає заявок для обробки.")

# Головний цикл програми
if __name__ == "__main__":
    print("Симуляція роботи сервісного центру. Натисніть Ctrl+C для виходу.")
    try:
        while True:
            # Випадково генеруємо або обробляємо заявки
            if random.random() < 0.7: # З ймовірністю 70% генеруємо нову заявку
                generate_request()
            
            if random.random() < 0.5 or not request_queue.empty(): # З ймовірністю 50% або якщо черга не пуста
                process_request()
            
            # Пауза для імітації реального часу
            time.sleep(random.uniform(0.3, 1))
            
            # Для демонстрації можна обмежити кількість ітерацій або додати умову виходу
            # Наприклад, якщо черга оброблена і певний час не було нових заявок

    except KeyboardInterrupt:
        print("\nПрограма завершена користувачем.")
    finally:
        # Очікуємо, поки всі елементи в черзі будуть оброблені, якщо це потрібно
        # request_queue.join() # Це заблокує, якщо черга не пуста і task_done не викликався для всіх елементів
        print("Сервісний центр припиняє роботу.")
````

------------


## Завдання 2: Перевірка на паліндром

**Мета:** *Розробити функцію, яка перевіряє, чи є заданий рядок паліндромом.*

**Структура даних:** Двостороння черга (***deque*** з модуля ***collections*** ).

### Підхід:

1. Функція приймає рядок як вхідний параметр.

2. Рядок нормалізується: переводиться у нижній регістр та з нього видаляються пробіли.

3. Всі символи нормалізованого рядка додаються до двосторонньої черги.

4. Символи порівнюються з обох кінців черги: перший з останнім, другий з передостаннім і т.д.

5. Якщо всі відповідні пари символів однакові, рядок є паліндромом. Функція має коректно працювати як з рядками парної, так і непарної довжини.

**Ось код для реалізації:**

```python
from collections import deque

def is_palindrome(input_string: str) -> bool:
    """
    Перевіряє, чи є рядок паліндромом.
    Нечутлива до регістру та пробілів.
    """
    # Нормалізація рядка: нижній регістр та видалення пробілів
    normalized_string = ''.join(input_string.lower().split())
    
    if not normalized_string: # Порожній рядок або рядок з одних пробілів вважається паліндромом
        return True
        
    char_deque = deque(normalized_string)
    
    while len(char_deque) > 1:
        first_char = char_deque.popleft()
        last_char = char_deque.pop()
        if first_char != last_char:
            return False
            
    return True

# Приклади використання:
if __name__ == "__main__":
    print(f"'А роза упала на лапу Азора' є паліндромом: {is_palindrome('А роза упала на лапу Азора')}")
    print(f"'Race car' є паліндромом: {is_palindrome('Race car')}")
    print(f"'hello' є паліндромом: {is_palindrome('hello')}")
    print(f"'madam' є паліндромом: {is_palindrome('madam')}")
    print(f"' ' є паліндромом: {is_palindrome(' ')}") # Порожній після нормалізації
    print(f"'' є паліндромом: {is_palindrome('')}")   # Порожній рядок
    print(f"'A' є паліндромом: {is_palindrome('A')}")     # Рядок з одного символу
```

------------


## Завдання 3 (необов'язкове): Перевірка симетричності розділювачів

**Мета:** *Написати програму, яка читає рядок з послідовністю символів-розділювачів* **((), [], {})** *і визначає, чи є вони симетричними.*

**Структура даних:** Стек (реалізований за допомогою списку ***Python***).

### Підхід:

1. Ініціалізувати порожній стек.

1. Створити словник для відповідності закриваючих дужок відкриваючим.

1. Ітерувати по кожному символу вхідного рядка:
- Якщо символ є відкриваючою дужкою **((, [, {)**, додати його до стеку.
- Якщо символ є закриваючою дужкою **(), ], })**:
    - Якщо стек порожній, або верхній елемент стеку не є відповідною відкриваючою дужкою, то послідовність несиметрична.
    - Інакше, видалити верхній елемент зі стеку (пару знайдено).
- Інші символи (не дужки) ігноруються, як показано у прикладі **()[1](1+3)(){}}**. 

4.Після проходження всього рядка:
- Якщо стек порожній, всі дужки були симетрично закриті.
- Якщо в стеку залишились елементи, це означає, що деякі відкриваючі дужки не були закриті, отже, послідовність несиметрична.

**Ось код для реалізації:**

```python
def check_delimiters(s: str) -> str:
    """
    Перевіряє симетричність розділювачів у рядку.
    Ігнорує символи, що не є розділювачами.
    """
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    open_brackets = "([{"
    close_brackets = ")]}"
    
    for char in s:
        if char in open_brackets:
            stack.append(char)
        elif char in close_brackets:
            if not stack: # Закриваюча дужка без відповідної відкриваючої
                return "Несиметрично"
            top_element = stack.pop()
            if mapping[char] != top_element: # Невідповідність типів дужок
                return "Несиметрично"
        # Інші символи ігноруються
        
    if not stack: # Якщо стек порожній, всі дужки збалансовані
        return "Симетрично"
    else: # Якщо в стеку залишились відкриваючі дужки
        return "Несиметрично"

# Приклади використання:
if __name__ == "__main__":
    print(f"'(){{[](){{}}}}' -> {check_delimiters('(){[](){{}}}}')}") # Симетрично [cite: 12] (змінено для чистоти прикладу з ДЗ)
    print(f"'((()' -> {check_delimiters('((()')}")                    # Несиметрично [cite: 12]
    print(f"'([)]' -> {check_delimiters('([)]')}")                   # Несиметрично (припускаючи, що '(.' означало такий випадок)
    print(f"'()[1](1+3)(){{}}' -> {check_delimiters('()[1](1+3)(){{}}')}") # Симетрично [cite: 12]
    print(f"'((' -> {check_delimiters('((')}")                         # Несиметрично
    print(f"'))' -> {check_delimiters('))')}")                         # Несиметрично
    print(f"'{{[()]}}' -> {check_delimiters('{{[()]}}')}")               # Симетрично
    print(f"'{{[()]}}(' -> {check_delimiters('{{[()]}}(')}")             # Несиметрично
    print(f"'(11):' -> {check_delimiters('(11):')}")                   # Несиметрично (якщо дужки - частина виразу) [cite: 12]
    print(f"'(23 $(\\overline{{z}}-3)i:$' -> {check_delimiters('(23 $(\\overline{{z}}-3)i:')}") # Несиметрично (якщо дужки - частина виразу) [cite: 12]
```

------------
